<!doctype html>
<notebook theme="midnight">
  <title>LNG Attribution Explorer</title>

  <script id="title" type="text/markdown">
# *Nom de plume*

The list below shows oil and gas infrastructure — mostly wells — which have been linked to methane plumes meeting the US Environmental Protection Agency's definition of a 'super-emitter event' (at least 100 kg/hr), published by [Carbon Mapper](https://data.carbonmapper.org/).
  </script>

  <!-- Get first 500 plumes ordered by most recent -->
  <script id="plumes-sql" type="application/sql" database="data/data.duckdb" output="plumes" hidden>
SELECT
  id,
  entity_name as operator,
  rate_kg_hr,
  datetime,
  latitude,
  longitude,
  nearest_facility_id,
  nearest_facility_type,
  distance_to_nearest_facility_km,
  total_facilities_nearby,
  operator_facilities_of_type,
  confidence_score
FROM emissions.attributed
WHERE rate_kg_hr >= 100
  AND confidence_score >= 75
  AND distance_to_nearest_facility_km <= 0.5
ORDER BY datetime DESC
LIMIT 500
  </script>

  <!-- Pre-load ALL infrastructure for the plumes we're showing -->
  <script id="infrastructure-sql" type="application/sql" database="data/data.duckdb" output="infrastructure" hidden>
INSTALL spatial;
LOAD spatial;

WITH plume_locations AS (
  SELECT
    id,
    latitude,
    longitude
  FROM emissions.attributed
  WHERE rate_kg_hr >= 100
    AND confidence_score >= 75
    AND distance_to_nearest_facility_km <= 0.5
  ORDER BY datetime DESC
  LIMIT 500
)
SELECT
  p.id as plume_id,
  f.facility_id,
  f.infra_type,
  f.operator,
  f.facility_subtype,
  ST_Y(f.geom) as latitude,
  ST_X(f.geom) as longitude,
  ROUND(ST_Distance(
    ST_Point(p.longitude, p.latitude),
    f.geom
  ) * 111 * 1000, 0) as distance_m
FROM plume_locations p
CROSS JOIN infrastructure.all_facilities f
WHERE ST_DWithin(
  ST_Point(p.longitude, p.latitude),
  f.geom,
  0.015
)
ORDER BY p.id, distance_m
  </script>

  <script id="plume-cards" type="module">
// Add responsive styles for card details and search
const style = document.createElement('style');
style.textContent = `
  .card-details {
    opacity: 0.7;
    font-size: 0.9em;
    text-align: right;
    margin-left: auto;
  }

  .search-container {
    margin-bottom: 1.5rem;
  }

  .search-input {
    width: 100%;
    max-width: 400px;
    padding: 0.5rem 0.75rem;
    font-size: 1rem;
    border: 1px solid #666;
    border-radius: 4px;
    background: #1a1a1a;
    color: #fff;
  }

  .search-input::placeholder {
    color: #888;
  }

  @media (max-width: 768px) {
    .card-details {
      margin-left: 0 !important;
      text-align: left !important;
      flex-basis: 100% !important;
    }
  }
`;
document.head.appendChild(style);

// Create wrapper container
const wrapper = document.createElement('div');

// Add search input
const searchContainer = document.createElement('div');
searchContainer.className = 'search-container';

const searchInput = document.createElement('input');
searchInput.type = 'text';
searchInput.className = 'search-input';
searchInput.placeholder = 'Search operator...';

searchContainer.appendChild(searchInput);
wrapper.appendChild(searchContainer);

// Add horizontal rule
const hr = document.createElement('hr');
hr.style.marginBottom = '1.5rem';
wrapper.appendChild(hr);

// Cards container
const cardsContainer = document.createElement('div');
wrapper.appendChild(cardsContainer);

let currentlyExpanded = null;
let allPlumes = [...plumes];

const renderCards = () => {
  const searchTerm = searchInput.value.trim().toLowerCase();

  let filteredPlumes = allPlumes;
  if (searchTerm) {
    filteredPlumes = allPlumes.filter(p =>
      (p.operator || '').toLowerCase().includes(searchTerm)
    );
  }

  cardsContainer.innerHTML = '';
  currentlyExpanded = null;

  if (filteredPlumes.length === 0) {
    cardsContainer.innerHTML = '<p style="opacity: 0.7;">No matching plumes found</p>';
    return;
  }

  for (let i = 0; i < filteredPlumes.length; i++) {
    const plume = filteredPlumes[i];
    const cardId = `card-${i}`;
    const mapId = `map-${i}`;
    const detailsId = `details-${i}`;

    const card = document.createElement('div');
    card.id = cardId;
    card.style.marginBottom = '0.5rem';

    const header = document.createElement('div');
    header.style.cursor = 'pointer';
    header.onclick = () => {
      const expandedContent = document.getElementById(`expanded-${i}`);
      const isExpanded = currentlyExpanded === i;

      if (isExpanded) {
        expandedContent.style.display = 'none';
        currentlyExpanded = null;
      } else {
        if (currentlyExpanded !== null) {
          document.getElementById(`expanded-${currentlyExpanded}`).style.display = 'none';
        }

        expandedContent.style.display = 'grid';
        currentlyExpanded = i;

        const mapContainer = document.getElementById(mapId);
        if (!mapContainer.dataset.loaded) {
          loadMap(i, plume);
          mapContainer.dataset.loaded = 'true';
        }
      }
    };

    const observationDate = plume.datetime ? new Date(plume.datetime).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : 'N/A';

    header.style.display = 'flex';
    header.style.flexWrap = 'wrap';
    header.style.alignItems = 'baseline';
    header.style.gap = '0.75rem';

    header.innerHTML = `
      <h3 style="margin: 0; font-size: 1rem; font-weight: 600;">
        ${plume.operator || 'Unknown Operator'}
      </h3>
      <div class="card-details">
        ${observationDate} / ${plume.nearest_facility_type || 'Unknown'} / ${(plume.distance_to_nearest_facility_km * 1000)?.toFixed(0) || 'N/A'} m / ${plume.rate_kg_hr?.toFixed(1) || 'N/A'} kg/hr
      </div>
    `;

    const expandedContent = document.createElement('div');
    expandedContent.id = `expanded-${i}`;
    expandedContent.style.cssText = `
      display: none;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-top: 1.5rem;
      align-items: start;
    `;

    const detailsPanel = document.createElement('div');
    detailsPanel.id = detailsId;

    const formatDate = (dateStr) => {
      if (!dateStr) return 'N/A';
      const d = new Date(dateStr);
      return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    };

    detailsPanel.innerHTML = `
      <table style="width: 100%; border-collapse: collapse; margin-bottom: 1.5rem;">
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>plume id</strong></td>
          <td style="padding: 0.5rem 0;"><code style="font-size: 0.85em;"><a href="https://data.carbonmapper.org/?details=${plume.id}" target="_blank" style="color: inherit; text-decoration: underline;">${plume.id}</a></code></td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>operator</strong></td>
          <td style="padding: 0.5rem 0;">${plume.operator || 'Unknown'}</td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>facility type</strong></td>
          <td style="padding: 0.5rem 0;">${plume.nearest_facility_type || 'Unknown'}</td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>facility id</strong></td>
          <td style="padding: 0.5rem 0;"><code style="font-size: 0.85em;">${plume.nearest_facility_id}</code></td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>distance</strong></td>
          <td style="padding: 0.5rem 0;">${(plume.distance_to_nearest_facility_km * 1000)?.toFixed(0) || 'N/A'} metres from plume</td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>emission rate</strong></td>
          <td style="padding: 0.5rem 0;">${plume.rate_kg_hr?.toFixed(1) || 'N/A'} kg/hr</td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>observation date</strong></td>
          <td style="padding: 0.5rem 0;">${formatDate(plume.datetime)}</td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>confidence</strong></td>
          <td style="padding: 0.5rem 0;">${plume.confidence_score?.toFixed(1) || 'N/A'}%</td>
        </tr>
        <tr>
          <td style="padding: 0.5rem 1rem 0.5rem 0; vertical-align: top;"><strong>facilities within 1.5 km</strong></td>
          <td style="padding: 0.5rem 0;">${plume.operator_facilities_of_type || 0} same operator, ${plume.total_facilities_nearby} total</td>
        </tr>
      </table>
      <div id="legend-${i}" style="font-size: 0.85em; line-height: 1.6;"></div>
    `;

    const mapPanel = document.createElement('div');
    mapPanel.id = mapId;

    expandedContent.appendChild(detailsPanel);
    expandedContent.appendChild(mapPanel);

    card.appendChild(header);
    card.appendChild(expandedContent);
    cardsContainer.appendChild(card);
  }
};

searchInput.addEventListener('input', renderCards);
renderCards();
display(wrapper);
  </script>

  <script id="leaflet-loader" type="module">
const loadLeaflet = async () => {
  if (!globalThis.L) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
    document.head.appendChild(link);

    await new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  return globalThis.L;
};

globalThis.loadLeaflet = loadLeaflet;
  </script>

  <script id="map-loader" type="module">
async function loadMap(index, plume) {
  const L = await loadLeaflet();
  const mapId = `map-${index}`;
  const mapPanel = document.getElementById(mapId);

  const mapDiv = document.createElement('div');
  mapDiv.style.cssText = 'height: 420px; border-radius: 4px; margin-bottom: 15px;';
  mapPanel.appendChild(mapDiv);

  const map = L.map(mapDiv, {
    zoomControl: false
  }).setView([plume.latitude, plume.longitude], 14);

  L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Tiles © Esri',
    maxZoom: 19,
    className: 'grayscale-tiles'
  }).addTo(map);

  const style = document.createElement('style');
  style.textContent = '.grayscale-tiles { filter: grayscale(100%) brightness(0.6); }';
  document.head.appendChild(style);

  const plumeMarker = L.circleMarker([plume.latitude, plume.longitude], {
    radius: 10,
    fillColor: '#D94848',
    color: 'transparent',
    weight: 0,
    opacity: 1,
    fillOpacity: 0.9
  }).addTo(map);

  const formatPopupDate = (dateStr) => {
    if (!dateStr) return 'N/A';
    const d = new Date(dateStr);
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  };

  plumeMarker.bindTooltip(`
    <strong>methane plume</strong><br>
    ${plume.rate_kg_hr?.toFixed(1)} kg/hr<br>
    ${formatPopupDate(plume.datetime)}
  `, { permanent: false, sticky: false });

  const typeColors = {
    'well': '#60BF66',
    'compressor': '#F1C644',
    'processing': '#F28322',
    'tank_battery': '#9461C7',
    'injection_disposal': '#D94848',
    'petroleum_terminal': '#F28322',
    'station_other': '#9461C7',
    'lng_facility': '#D94848',
    'refinery': '#F28322'
  };

  const plumeInfra = infrastructure.filter(f => f.plume_id === plume.id);

  // Count distinct facilities by type
  const facilityIdsByType = {};
  const infraCounts = {};

  for (const facility of plumeInfra) {
    if (!facilityIdsByType[facility.infra_type]) {
      facilityIdsByType[facility.infra_type] = new Set();
    }
    facilityIdsByType[facility.infra_type].add(facility.facility_id);

    const color = typeColors[facility.infra_type] || '#aaa';
    const isMatched = facility.facility_id === plume.nearest_facility_id;

    const marker = L.circleMarker([facility.latitude, facility.longitude], {
      radius: isMatched ? 8 : 4,
      fillColor: color,
      color: 'transparent',
      weight: 0,
      opacity: 1,
      fillOpacity: isMatched ? 1.0 : 0.7
    }).addTo(map);

    marker.bindTooltip(`
      <strong>${facility.infra_type}</strong><br>
      Operator: ${facility.operator || 'Unknown'}<br>
      Distance: ${facility.distance_m}m<br>
      <small>${facility.facility_id}</small>
    `, { permanent: false, sticky: false });
  }

  // Convert sets to counts
  for (const [type, ids] of Object.entries(facilityIdsByType)) {
    infraCounts[type] = ids.size;
  }

  const legendDiv = document.getElementById(`legend-${index}`);

  let legendContent = '<div><span style="color: #D94848; font-size: 1.2em;">●</span> methane plume</div>';

  if (infraCounts.well) legendContent += `<div><span style="color: #60BF66;">●</span> wells (${infraCounts.well})</div>`;
  if (infraCounts.compressor) legendContent += `<div><span style="color: #F1C644;">●</span> compressors (${infraCounts.compressor})</div>`;
  if (infraCounts.processing) legendContent += `<div><span style="color: #F28322;">●</span> processing (${infraCounts.processing})</div>`;
  if (infraCounts.tank_battery) legendContent += `<div><span style="color: #9461C7;">●</span> tank batteries (${infraCounts.tank_battery})</div>`;
  if (infraCounts.injection_disposal) legendContent += `<div><span style="color: #D94848;">●</span> injection/disposal (${infraCounts.injection_disposal})</div>`;
  if (infraCounts.petroleum_terminal) legendContent += `<div><span style="color: #F28322;">●</span> terminals (${infraCounts.petroleum_terminal})</div>`;
  if (infraCounts.lng_facility) legendContent += `<div><span style="color: #D94848;">●</span> lng facilities (${infraCounts.lng_facility})</div>`;
  if (infraCounts.refinery) legendContent += `<div><span style="color: #F28322;">●</span> refineries (${infraCounts.refinery})</div>`;

  legendDiv.innerHTML = legendContent;

  setTimeout(() => map.invalidateSize(), 100);
}

globalThis.loadMap = loadMap;
  </script>

</notebook>
